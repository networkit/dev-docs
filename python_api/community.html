
<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>networkit.community</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../_static/bootstrap-sphinx.css?v=fa2d15c4" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery.css?v=d2d258e8" />
    <link rel="stylesheet" type="text/css" href="../_static/bootstrap-treeview/bootstrap-treeview.min.css?v=8176a87d" />
    <link rel="stylesheet" href="../_static/style.css" type="text/css" />
    <script src="../_static/documentation_options.js?v=89fba709"></script>
    <script src="../_static/doctools.js?v=fd6eb6e6"></script>
    <script src="../_static/sphinx_highlight.js?v=6ffebe34"></script>
    <script src="../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../_static/copybutton.js?v=f281be69"></script>
    <script src="../_static/bootstrap-treeview/bootstrap-treeview.min.js?v=6a1e96b4"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@^1.0.1/dist/embed-amd.js"></script>
    <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@4/tex-mml-chtml.js"></script>
    <script src="../_static/particles.min.js"></script>
    <script src="../_static/custom.js"></script>
    <script src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="networkit.components" href="components.html" />
    <link rel="prev" title="networkit.coloring" href="coloring.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">
<script type="text/javascript" src="../_static/js/jquery-1.12.4.min.js"></script>
<script type="text/javascript" src="../_static/js/jquery-fix.js"></script>
<script type="text/javascript" src="../_static/bootstrap-3.4.1/js/bootstrap.min.js"></script>
<script type="text/javascript" src="../_static/bootstrap-sphinx.js"></script>

  </head><body>
  
  <a href="https://github.com/networkit/networkit"
     class="visible-desktop hidden-xs"><img style="position: absolute; width:auto; height: auto; max-width: 200px; top:
     0px; right: 0; border: 0; z-index: 3;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_white_ffffff.png" alt="Fork me on GitHub"></a>  


     <div id="fancy-particles-small"></div>
  <div id="navbar" class="navbar navbar-default ">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>

        <div style="float:left;height:auto; line-height:30px;">
          <div style="overflow:hidden; line-height:15px">
              <span style="display:block">
                <a style="text-decoration: none; padding-top: 19.5px; padding-left:15px; height:30px;" class="navbar-brand" href="https://networkit.github.io">
                  NetworKit</a>
              </span>
              <div style="font-size:9pt; clear:left;">Large-Scale Network Analysis</div>              
          </div>
        </div>
      </div>



        <div id="main-nav" class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="https://networkit.github.io/get_started.html">Get Started</a></li>
                <li><a href="../index.html">Documentation</a></li>
                <li><a href="https://networkit.github.io/features.html">Features</a></li>
                <li><a href="https://networkit.github.io/news.html">News</a></li>
                <li><a href="https://networkit.github.io/publications.html">Publications</a></li>
                <li><a href="https://networkit.github.io/networkit-day.html">NetworKit Day</a></li>
                <li><a href="https://networkit.github.io/credits.html">Credits & References</a></li>
            
            
              
            
            
            
            
            
          </ul>
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
      <div class="col-md-3">
        <div id="sidebar" class="bs-sidenav" role="complementary"><ul class="sidebar">
	<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="modules.html">Python Documentation</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="modules.html#modules">Modules</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="networkit.html">networkit</a></li>
<li class="toctree-l3"><a class="reference internal" href="algebraic.html">networkit.algebraic</a></li>
<li class="toctree-l3"><a class="reference internal" href="base.html">networkit.base</a></li>
<li class="toctree-l3"><a class="reference internal" href="centrality.html">networkit.centrality</a></li>
<li class="toctree-l3"><a class="reference internal" href="clique.html">networkit.clique</a></li>
<li class="toctree-l3"><a class="reference internal" href="coarsening.html">networkit.coarsening</a></li>
<li class="toctree-l3"><a class="reference internal" href="coloring.html">networkit.coloring</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">networkit.community</a></li>
<li class="toctree-l3"><a class="reference internal" href="components.html">networkit.components</a></li>
<li class="toctree-l3"><a class="reference internal" href="correlation.html">networkit.correlation</a></li>
<li class="toctree-l3"><a class="reference internal" href="distance.html">networkit.distance</a></li>
<li class="toctree-l3"><a class="reference internal" href="dynamic.html">networkit.dynamic</a></li>
<li class="toctree-l3"><a class="reference internal" href="dynamics.html">networkit.dynamics</a></li>
<li class="toctree-l3"><a class="reference internal" href="dynbase.html">networkit.dynbase</a></li>
<li class="toctree-l3"><a class="reference internal" href="embedding.html">networkit.embedding</a></li>
<li class="toctree-l3"><a class="reference internal" href="engineering.html">networkit.engineering</a></li>
<li class="toctree-l3"><a class="reference internal" href="flow.html">networkit.flow</a></li>
<li class="toctree-l3"><a class="reference internal" href="generators.html">networkit.generators</a></li>
<li class="toctree-l3"><a class="reference internal" href="gephi.html">networkit.gephi</a></li>
<li class="toctree-l3"><a class="reference internal" href="globals.html">networkit.globals</a></li>
<li class="toctree-l3"><a class="reference internal" href="graph.html">networkit.graph</a></li>
<li class="toctree-l3"><a class="reference internal" href="graphio.html">networkit.graphio</a></li>
<li class="toctree-l3"><a class="reference internal" href="graphtools.html">networkit.graphtools</a></li>
<li class="toctree-l3"><a class="reference internal" href="helpers.html">networkit.helpers</a></li>
<li class="toctree-l3"><a class="reference internal" href="independentset.html">networkit.independentset</a></li>
<li class="toctree-l3"><a class="reference internal" href="linkprediction.html">networkit.linkprediction</a></li>
<li class="toctree-l3"><a class="reference internal" href="matching.html">networkit.matching</a></li>
<li class="toctree-l3"><a class="reference internal" href="nxadapter.html">networkit.nxadapter</a></li>
<li class="toctree-l3"><a class="reference internal" href="plot.html">networkit.plot</a></li>
<li class="toctree-l3"><a class="reference internal" href="profiling.html">networkit.profiling</a></li>
<li class="toctree-l3"><a class="reference internal" href="randomization.html">networkit.randomization</a></li>
<li class="toctree-l3"><a class="reference internal" href="reachability.html">networkit.reachability</a></li>
<li class="toctree-l3"><a class="reference internal" href="scd.html">networkit.scd</a></li>
<li class="toctree-l3"><a class="reference internal" href="simulation.html">networkit.simulation</a></li>
<li class="toctree-l3"><a class="reference internal" href="sparsification.html">networkit.sparsification</a></li>
<li class="toctree-l3"><a class="reference internal" href="stats.html">networkit.stats</a></li>
<li class="toctree-l3"><a class="reference internal" href="structures.html">networkit.structures</a></li>
<li class="toctree-l3"><a class="reference internal" href="traversal.html">networkit.traversal</a></li>
<li class="toctree-l3"><a class="reference internal" href="viz.html">networkit.viz</a></li>
<li class="toctree-l3"><a class="reference internal" href="vizbridges.html">networkit.vizbridges</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../cpp_api/library_root.html">C++ Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../notebooks.html">Jupyter Notebook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../DevGuide.html">Developer Guide</a></li>
</ul>

</ul>
  
<form action="../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
        </div>
      </div>
    <div class="col-md-9 content">
      
  <section id="module-networkit.community">
<span id="networkit-community"></span><h1>networkit.community<a class="headerlink" href="#module-networkit.community" title="Link to this heading">¶</a></h1>
<dl class="py class">
<dt class="sig sig-object py" id="networkit.community.AdjustedRandMeasure">
<span class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></span><span class="sig-prename descclassname"><span class="pre">networkit.community.</span></span><span class="sig-name descname"><span class="pre">AdjustedRandMeasure</span></span><a class="headerlink" href="#networkit.community.AdjustedRandMeasure" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#networkit.community.DissimilarityMeasure" title="networkit.community.DissimilarityMeasure"><code class="xref py py-class docutils literal notranslate"><span class="pre">DissimilarityMeasure</span></code></a></p>
<p>The adjusted rand dissimilarity measure as proposed by Huber and Arabie in “Comparing partitions” (<a class="reference external" href="http://link.springer.com/article/10.1007/BF01908075">http://link.springer.com/article/10.1007/BF01908075</a>)</p>
<dl class="py method">
<dt class="sig sig-object py" id="networkit.community.AdjustedRandMeasure.getDissimilarity">
<span class="sig-name descname"><span class="pre">getDissimilarity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">first</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">second</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#networkit.community.AdjustedRandMeasure.getDissimilarity" title="Link to this definition">¶</a></dt>
<dd><p>Returns dissimilarity between two partitions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> (<em>networkit.Graph</em>) – The input graph.</p></li>
<li><p><strong>first</strong> (<em>networkit.Partition</em>) – The first partition.</p></li>
<li><p><strong>second</strong> (<em>networkit.Partition</em>) – The second partition.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Dissimilarity between partition first and second.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="networkit.community.ClusteringGenerator">
<span class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></span><span class="sig-prename descclassname"><span class="pre">networkit.community.</span></span><span class="sig-name descname"><span class="pre">ClusteringGenerator</span></span><a class="headerlink" href="#networkit.community.ClusteringGenerator" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Generators for various clusterings</p>
<dl class="py method">
<dt class="sig sig-object py" id="networkit.community.ClusteringGenerator.makeContinuousBalancedClustering">
<span class="sig-name descname"><span class="pre">makeContinuousBalancedClustering</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#networkit.community.ClusteringGenerator.makeContinuousBalancedClustering" title="Link to this definition">¶</a></dt>
<dd><p>Generate a clustering with <cite>k</cite> clusters to which nodes are assigned in continuous blocks</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> (<em>networkit.Graph</em>) – The graph for which the clustering shall be generated.</p></li>
<li><p><strong>k</strong> (<em>int</em>) – The number of clusters that shall be generated.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The generated partition.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>networkit.Partition</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="networkit.community.ClusteringGenerator.makeNoncontinuousBalancedClustering">
<span class="sig-name descname"><span class="pre">makeNoncontinuousBalancedClustering</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#networkit.community.ClusteringGenerator.makeNoncontinuousBalancedClustering" title="Link to this definition">¶</a></dt>
<dd><p>Generate a clustering with <cite>k</cite> clusters, the ith node is assigned to cluster i % k. This means that
for k**2 nodes, this clustering is complementary to the continuous clustering in the sense that no pair
of nodes that is in the same cluster in one of the clusterings is in the same cluster in the other clustering.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> (<em>networkit.Graph</em>) – The graph for which the clustering shall be generated.</p></li>
<li><p><strong>k</strong> (<em>int</em>) – The number of clusters that shall be generated.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The generated partition.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>networkit.Partition</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="networkit.community.ClusteringGenerator.makeOneClustering">
<span class="sig-name descname"><span class="pre">makeOneClustering</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#networkit.community.ClusteringGenerator.makeOneClustering" title="Link to this definition">¶</a></dt>
<dd><p>Generate a clustering with one cluster consisting of all nodes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>G</strong> (<em>networkit.Graph</em>) – The graph for which the clustering shall be generated.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The generated partition.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>networkit.Partition</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="networkit.community.ClusteringGenerator.makeRandomClustering">
<span class="sig-name descname"><span class="pre">makeRandomClustering</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#networkit.community.ClusteringGenerator.makeRandomClustering" title="Link to this definition">¶</a></dt>
<dd><p>Generate a clustering with <cite>k</cite> clusters to which nodes are assigned randomly.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> (<em>networkit.Graph</em>) – The graph for which the clustering shall be generated.</p></li>
<li><p><strong>k</strong> (<em>int</em>) – The number of clusters that shall be generated.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The generated partition.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>networkit.Partition</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="networkit.community.ClusteringGenerator.makeSingletonClustering">
<span class="sig-name descname"><span class="pre">makeSingletonClustering</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#networkit.community.ClusteringGenerator.makeSingletonClustering" title="Link to this definition">¶</a></dt>
<dd><p>Generate a clustering where each node has its own cluster</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>G</strong> (<em>networkit.Graph</em>) – The graph for which the clustering shall be generated.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The generated partition.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>networkit.Partition</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="networkit.community.CommunityDetector">
<span class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></span><span class="sig-prename descclassname"><span class="pre">networkit.community.</span></span><span class="sig-name descname"><span class="pre">CommunityDetector</span></span><a class="headerlink" href="#networkit.community.CommunityDetector" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="base.html#networkit.base.Algorithm" title="networkit.base.Algorithm"><code class="xref py py-class docutils literal notranslate"><span class="pre">Algorithm</span></code></a></p>
<p>Abstract base class for static community detection algorithms.</p>
<dl class="py method">
<dt class="sig sig-object py" id="networkit.community.CommunityDetector.getPartition">
<span class="sig-name descname"><span class="pre">getPartition</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#networkit.community.CommunityDetector.getPartition" title="Link to this definition">¶</a></dt>
<dd><p>Returns a partition of the clustering.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A Partition of the clustering.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>networkit.Partition</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="networkit.community.CoverF1Similarity">
<span class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></span><span class="sig-prename descclassname"><span class="pre">networkit.community.</span></span><span class="sig-name descname"><span class="pre">CoverF1Similarity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">C</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reference</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#networkit.community.CoverF1Similarity" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#networkit.community.LocalCoverEvaluation" title="networkit.community.LocalCoverEvaluation"><code class="xref py py-class docutils literal notranslate"><span class="pre">LocalCoverEvaluation</span></code></a></p>
<p>Compare a given cover to a reference cover using the F1 measure.
This is a typical similarity measure used to compare the found
overlapping community structure to a ground truth community
structure. Each cluster is compared to the best-matching reference
cluster (in terms of highest F1 score). A value of 1 indicates
perfect agreement while a while of 0 indicates complete
disagreement. An example where this measure is used is the
following paper:</p>
<p>Alessandro Epasto, Silvio Lattanzi, and Renato Paes
Leme. 2017. Ego-Splitting Framework: from Non-Overlapping to
Overlapping Clusters. In Proceedings of the 23rd ACM SIGKDD
International Conference on Knowledge Discovery and Data Mining
(KDD ‘17). ACM, New York, NY, USA, 145-154. DOI:
<a class="reference external" href="https://doi.org/10.1145/3097983.3098054">https://doi.org/10.1145/3097983.3098054</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> (<em>networkit.Graph</em>) – The graph on which the evaluation is performed.</p></li>
<li><p><strong>C</strong> (<em>networkit.Cover</em>) – The cover that shall be evaluated.</p></li>
<li><p><strong>reference</strong> (<em>networkit.Cover</em>) – The cover to which the similarity shall be computed.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="networkit.community.CoverHubDominance">
<span class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></span><span class="sig-prename descclassname"><span class="pre">networkit.community.</span></span><span class="sig-name descname"><span class="pre">CoverHubDominance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">C</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#networkit.community.CoverHubDominance" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#networkit.community.LocalCoverEvaluation" title="networkit.community.LocalCoverEvaluation"><code class="xref py py-class docutils literal notranslate"><span class="pre">LocalCoverEvaluation</span></code></a></p>
<p>A quality measure that measures the dominance of hubs in clusters. The hub dominance of a single
cluster is defined as the maximum cluster-internal degree of a node in that cluster divided by
the maximum cluster-internal degree, i.e. the number of nodes in the cluster minus one. The
value for all clusters is defined as the average of all clusters.
This implementation is a natural generalization of this measure for covers.
Strictly speaking this is not a quality measure as this is rather dependent on the type of the
considered graph, for more information see
Lancichinetti A, Kivel M, Saramki J, Fortunato S (2010)
Characterizing the Community Structure of Complex Networks
PLoS ONE 5(8): e11976. doi: 10.1371/journal.pone.0011976
<a class="reference external" href="http://www.plosone.org/article/info%3Adoi%2F10.1371%2Fjournal.pone.0011976">http://www.plosone.org/article/info%3Adoi%2F10.1371%2Fjournal.pone.0011976</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> (<em>networkit.Graph</em>) – The graph on which the measure shall be evaluated.</p></li>
<li><p><strong>C</strong> (<em>networkit.Cover</em>) – The cover that shall be evaluated.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="networkit.community.Coverage">
<span class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></span><span class="sig-prename descclassname"><span class="pre">networkit.community.</span></span><span class="sig-name descname"><span class="pre">Coverage</span></span><a class="headerlink" href="#networkit.community.Coverage" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Coverage is the fraction of intra-community edges</p>
<dl class="py method">
<dt class="sig sig-object py" id="networkit.community.Coverage.getQuality">
<span class="sig-name descname"><span class="pre">getQuality</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Partition</span> <span class="pre">zeta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Graph</span> <span class="pre">G</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#networkit.community.Coverage.getQuality" title="Link to this definition">¶</a></dt>
<dd><p>Calculates the coverage in the given Partition of the given
Graph.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>zeta</strong> (<em>networkit.Partition</em>) – The Partition for which the coverage shall be calculated.</p></li>
<li><p><strong>G</strong> (<em>networkit.Graph</em>) – The Graph to which zeta belongs.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The coverage in the given Partition.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="networkit.community.CutClustering">
<span class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></span><span class="sig-prename descclassname"><span class="pre">networkit.community.</span></span><span class="sig-name descname"><span class="pre">CutClustering</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#networkit.community.CutClustering" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#networkit.community.CommunityDetector" title="networkit.community.CommunityDetector"><code class="xref py py-class docutils literal notranslate"><span class="pre">CommunityDetector</span></code></a></p>
<p>Cut clustering algorithm as defined in
Flake, Gary William; Tarjan, Robert E.; Tsioutsiouliklis, Kostas. Graph Clustering and Minimum Cut Trees.
Internet Mathematics 1 (2003), no. 4, 385–408.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> (<em>networkit.Graph</em>) – The input graph.</p></li>
<li><p><strong>alpha</strong> (<em>float</em>) – The parameter for the cut clustering algorithm.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="networkit.community.CutClustering.getClusterHierarchy">
<span class="property"><span class="k"><span class="pre">static</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">getClusterHierarchy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#networkit.community.CutClustering.getClusterHierarchy" title="Link to this definition">¶</a></dt>
<dd><p>Get the complete hierarchy with all possible parameter values.</p>
<p>Each reported parameter value is the lower bound for the range in which the corresponding clustering is calculated by the cut clustering algorithm.</p>
<p>Warning: all reported parameter values are slightly too high in order to avoid wrong clusterings because of numerical inaccuracies.
Furthermore the completeness of the hierarchy cannot be guaranteed because of these inaccuracies.
This implementation hasn’t been optimized for performance.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>G</strong> (<em>networkit.Graph</em>) – The input graph.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A dictionary with the parameter values as keys and the corresponding Partition instances as values.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dict(str <code class="docutils literal notranslate"><span class="pre">:</span></code> networkit.Partition)</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="networkit.community.DissimilarityMeasure">
<span class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></span><span class="sig-prename descclassname"><span class="pre">networkit.community.</span></span><span class="sig-name descname"><span class="pre">DissimilarityMeasure</span></span><a class="headerlink" href="#networkit.community.DissimilarityMeasure" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Abstract base class for partition/community dissimilarity measures</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="networkit.community.EdgeCut">
<span class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></span><span class="sig-prename descclassname"><span class="pre">networkit.community.</span></span><span class="sig-name descname"><span class="pre">EdgeCut</span></span><a class="headerlink" href="#networkit.community.EdgeCut" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Edge cut is the total weight of inter-community edges</p>
<dl class="py method">
<dt class="sig sig-object py" id="networkit.community.EdgeCut.getQuality">
<span class="sig-name descname"><span class="pre">getQuality</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">zeta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">G</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#networkit.community.EdgeCut.getQuality" title="Link to this definition">¶</a></dt>
<dd><p>Calculates the edgeCut in the given Partition of the given
Graph.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>zeta</strong> (<em>networkit.Partition</em>) – The Partition for which the edgeCut shall be calculated.</p></li>
<li><p><strong>G</strong> (<em>networkit.Graph</em>) – The Graph to which zeta belongs.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The edgeCut in the given Partition.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="networkit.community.GraphClusteringTools">
<span class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></span><span class="sig-prename descclassname"><span class="pre">networkit.community.</span></span><span class="sig-name descname"><span class="pre">GraphClusteringTools</span></span><a class="headerlink" href="#networkit.community.GraphClusteringTools" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="py method">
<dt class="sig sig-object py" id="networkit.community.GraphClusteringTools.communicationGraph">
<span class="property"><span class="k"><span class="pre">static</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">communicationGraph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">graph</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zeta</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#networkit.community.GraphClusteringTools.communicationGraph" title="Link to this definition">¶</a></dt>
<dd><p>Get the communication graph for a given graph and its partition.
A communication graph consists of a number of nodes, which equal
the number of clusters in the partition. The edges between nodes
in the communication graph account for the total edge weight for all
edges between two clusters. For unweighted graphs, the edge weight in
the communication graph is equal to the number of edges between two
clusters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>graph</strong> (<em>networkit.Graph</em>) – The input graph.</p></li>
<li><p><strong>zeta</strong> (<em>networkit.Partition</em>) – Partition, which contains information about clusters in the graph.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Communication graph given by the input graph and its partition.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>networkit.Graph</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="networkit.community.GraphClusteringTools.equalClustering">
<span class="property"><span class="k"><span class="pre">static</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">equalClustering</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">zeta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">G</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#networkit.community.GraphClusteringTools.equalClustering" title="Link to this definition">¶</a></dt>
<dd><p>Check whether two paritions are equal for a given graph.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>zeta</strong> (<em>networkit.Partition</em>) – The first partition.</p></li>
<li><p><strong>eta</strong> (<em>networkit.Partition</em>) – The second partition.</p></li>
<li><p><strong>G</strong> (<em>networkit.Graph</em>) – The input graph.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>True if both partitions are the same, False if not.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="networkit.community.GraphClusteringTools.getImbalance">
<span class="property"><span class="k"><span class="pre">static</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">getImbalance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">zeta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">G</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#networkit.community.GraphClusteringTools.getImbalance" title="Link to this definition">¶</a></dt>
<dd><p>Get the imbalance of clusters in the given partition.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>zeta</strong> (<em>networkit.Partition</em>) – The first partition.</p></li>
<li><p><strong>G</strong> (<em>networkit.Graph</em><em>, </em><em>optional</em>) – The input graph to compare the imbalance to. Default: None</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Imbalance of the partition.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="networkit.community.GraphClusteringTools.isOneClustering">
<span class="property"><span class="k"><span class="pre">static</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">isOneClustering</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zeta</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#networkit.community.GraphClusteringTools.isOneClustering" title="Link to this definition">¶</a></dt>
<dd><p>Check whether a partition is a one clustering for a given graph.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> (<em>networkit.Graph</em>) – The input graph.</p></li>
<li><p><strong>zeta</strong> (<em>networkit.Partition</em>) – The first partition.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>True if the partition is a one clustering, False if not.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="networkit.community.GraphClusteringTools.isProperClustering">
<span class="property"><span class="k"><span class="pre">static</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">isProperClustering</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zeta</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#networkit.community.GraphClusteringTools.isProperClustering" title="Link to this definition">¶</a></dt>
<dd><p>Check whether a partition is a proper clustering for a given graph.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> (<em>networkit.Graph</em>) – The input graph.</p></li>
<li><p><strong>zeta</strong> (<em>networkit.Partition</em>) – The first partition.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>True if the partition is a proper clustering, False if not.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="networkit.community.GraphClusteringTools.isSingletonClustering">
<span class="property"><span class="k"><span class="pre">static</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">isSingletonClustering</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zeta</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#networkit.community.GraphClusteringTools.isSingletonClustering" title="Link to this definition">¶</a></dt>
<dd><p>Check whether a partition is a singleton clustering for a given graph.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> (<em>networkit.Graph</em>) – The input graph.</p></li>
<li><p><strong>zeta</strong> (<em>networkit.Partition</em>) – The first partition.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>True if the partition is a singleton clustering, False if not.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="networkit.community.GraphClusteringTools.weightedDegreeWithCluster">
<span class="property"><span class="k"><span class="pre">static</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">weightedDegreeWithCluster</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">graph</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zeta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">u</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cid</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#networkit.community.GraphClusteringTools.weightedDegreeWithCluster" title="Link to this definition">¶</a></dt>
<dd><p>Get weightedDegree of node u for a cluster (represented by a partition) of index cid.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>graph</strong> (<em>networkit.Graph</em>) – The input graph.</p></li>
<li><p><strong>zeta</strong> (<em>networkit.Partition</em>) – Partition, which contains information about clusters in the graph.</p></li>
<li><p><strong>u</strong> (<em>int</em>) – The input node.</p></li>
<li><p><strong>cid</strong> (<em>int</em>) – Index of cluster.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>weighted degree of node u for cluster index cid.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="networkit.community.GraphStructuralRandMeasure">
<span class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></span><span class="sig-prename descclassname"><span class="pre">networkit.community.</span></span><span class="sig-name descname"><span class="pre">GraphStructuralRandMeasure</span></span><a class="headerlink" href="#networkit.community.GraphStructuralRandMeasure" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#networkit.community.DissimilarityMeasure" title="networkit.community.DissimilarityMeasure"><code class="xref py py-class docutils literal notranslate"><span class="pre">DissimilarityMeasure</span></code></a></p>
<p>The graph-structural Rand measure assigns a similarity value in [0,1]
to two partitions of a graph, by considering connected pairs of nodes.</p>
<dl class="py method">
<dt class="sig sig-object py" id="networkit.community.GraphStructuralRandMeasure.getDissimilarity">
<span class="sig-name descname"><span class="pre">getDissimilarity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">first</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">second</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#networkit.community.GraphStructuralRandMeasure.getDissimilarity" title="Link to this definition">¶</a></dt>
<dd><p>Returns dissimilarity between two partitions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> (<em>networkit.Graph</em>) – The graph.</p></li>
<li><p><strong>first</strong> (<em>networkit.Partition</em>) – The first partition.</p></li>
<li><p><strong>second</strong> (<em>networkit.Partition</em>) – The second partition.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Dissimilarity between partition first and second.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="networkit.community.HubDominance">
<span class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></span><span class="sig-prename descclassname"><span class="pre">networkit.community.</span></span><span class="sig-name descname"><span class="pre">HubDominance</span></span><a class="headerlink" href="#networkit.community.HubDominance" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A quality measure that measures the dominance of hubs in clusters. The hub dominance of a single
cluster is defined as the maximum cluster-internal degree of a node in that cluster divided by
the maximum cluster-internal degree, i.e. the number of nodes in the cluster minus one. The
value for all clusters is defined as the average of all clusters.</p>
<p>Strictly speaking this is not a quality measure as this is rather dependent on the type of the
considered graph, for more information see
Lancichinetti A, Kivel M, Saramki J, Fortunato S (2010)
Characterizing the Community Structure of Complex Networks
PLoS ONE 5(8): e11976. doi: 10.1371/journal.pone.0011976
<a class="reference external" href="http://www.plosone.org/article/info%3Adoi%2F10.1371%2Fjournal.pone.0011976">http://www.plosone.org/article/info%3Adoi%2F10.1371%2Fjournal.pone.0011976</a></p>
<dl class="py attribute">
<dt class="sig sig-object py" id="networkit.community.HubDominance.getQuality">
<span class="sig-name descname"><span class="pre">getQuality</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">zeta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">G</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#networkit.community.HubDominance.getQuality" title="Link to this definition">¶</a></dt>
<dd><p>Calculates the dominance of hubs in the given Partition or Cover of the given
Graph.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>zeta</strong> (<em>networkit.Partition</em><em> or </em><em>networkit.Cover</em>) – The Partition or Cover for which the hub dominance shall be calculated.</p></li>
<li><p><strong>G</strong> (<em>networkit.Graph</em>) – The Graph to which zeta belongs.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The average hub dominance in the given Partition or Cover.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="networkit.community.IntrapartitionDensity">
<span class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></span><span class="sig-prename descclassname"><span class="pre">networkit.community.</span></span><span class="sig-name descname"><span class="pre">IntrapartitionDensity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">P</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#networkit.community.IntrapartitionDensity" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#networkit.community.LocalPartitionEvaluation" title="networkit.community.LocalPartitionEvaluation"><code class="xref py py-class docutils literal notranslate"><span class="pre">LocalPartitionEvaluation</span></code></a></p>
<p>The intra-cluster density of a partition is defined as the number of existing edges divided by the number of possible edges.
The global value is the sum of all existing intra-cluster edges divided by the sum of all possible intra-cluster edges.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> (<em>networkit.Graph</em>) – The graph on which the measure shall be evaluated.</p></li>
<li><p><strong>P</strong> (<em>networkit.Partition</em>) – The partition that shall be evaluated.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="networkit.community.IntrapartitionDensity.getGlobal">
<span class="sig-name descname"><span class="pre">getGlobal</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#networkit.community.IntrapartitionDensity.getGlobal" title="Link to this definition">¶</a></dt>
<dd><p>Get the global intra-cluster density.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The global intra-cluster density.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>float</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="networkit.community.IsolatedInterpartitionConductance">
<span class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></span><span class="sig-prename descclassname"><span class="pre">networkit.community.</span></span><span class="sig-name descname"><span class="pre">IsolatedInterpartitionConductance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">P</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#networkit.community.IsolatedInterpartitionConductance" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#networkit.community.LocalPartitionEvaluation" title="networkit.community.LocalPartitionEvaluation"><code class="xref py py-class docutils literal notranslate"><span class="pre">LocalPartitionEvaluation</span></code></a></p>
<p>Isolated inter-partition conductance is a measure for how well a partition
(communtiy/cluster) is separated from the rest of the graph.</p>
<p>The conductance of a partition is defined as the weight of the cut divided
by the volume (the sum of the degrees) of the nodes in the partition or the
nodes in the rest of the graph, whatever is smaller. Small values thus indicate
that the cut is small compared to the volume of the smaller of the separated
parts. For the whole partitions usually the maximum or the unweighted average
is used.</p>
<p>See also Experiments on Density-Constrained Graph Clustering,
Robert Grke, Andrea Kappes and  Dorothea Wagner, JEA 2015:
<a class="reference external" href="http://dx.doi.org/10.1145/2638551">http://dx.doi.org/10.1145/2638551</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> (<em>networkit.Graph</em>) – The graph on which the measure shall be evaluated.</p></li>
<li><p><strong>P</strong> (<em>networkit.Partition</em>) – The partition that shall be evaluated.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="networkit.community.IsolatedInterpartitionExpansion">
<span class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></span><span class="sig-prename descclassname"><span class="pre">networkit.community.</span></span><span class="sig-name descname"><span class="pre">IsolatedInterpartitionExpansion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">P</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#networkit.community.IsolatedInterpartitionExpansion" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#networkit.community.LocalPartitionEvaluation" title="networkit.community.LocalPartitionEvaluation"><code class="xref py py-class docutils literal notranslate"><span class="pre">LocalPartitionEvaluation</span></code></a></p>
<p>Isolated inter-partition expansion is a measure for how well a partition
(communtiy/cluster) is separated from the rest of the graph.</p>
<p>The expansion of a partition is defined as the weight of the cut divided
by number of nodes in the partition or in the rest of the graph, whatever
is smaller. Small values thus indicate that the cut is small compared to
the size of the smaller of the separated parts. For the whole partitions
usually the maximum or the unweighted average is used. Note that expansion
values can be larger than 1.</p>
<p>See also Experiments on Density-Constrained Graph Clustering,
Robert Grke, Andrea Kappes and Dorothea Wagner, JEA 2015:
<a class="reference external" href="http://dx.doi.org/10.1145/2638551">http://dx.doi.org/10.1145/2638551</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> (<em>networkit.Graph</em>) – The graph on which the measure shall be evaluated.</p></li>
<li><p><strong>P</strong> (<em>networkit.Partition</em>) – The partition that shall be evaluated.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="networkit.community.JaccardMeasure">
<span class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></span><span class="sig-prename descclassname"><span class="pre">networkit.community.</span></span><span class="sig-name descname"><span class="pre">JaccardMeasure</span></span><a class="headerlink" href="#networkit.community.JaccardMeasure" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#networkit.community.DissimilarityMeasure" title="networkit.community.DissimilarityMeasure"><code class="xref py py-class docutils literal notranslate"><span class="pre">DissimilarityMeasure</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="networkit.community.JaccardMeasure.getDissimilarity">
<span class="sig-name descname"><span class="pre">getDissimilarity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">first</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">second</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#networkit.community.JaccardMeasure.getDissimilarity" title="Link to this definition">¶</a></dt>
<dd><p>Returns dissimilarity between two partitions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> (<em>networkit.Graph</em>) – The input graph.</p></li>
<li><p><strong>first</strong> (<em>networkit.Partition</em>) – The first partition.</p></li>
<li><p><strong>second</strong> (<em>networkit.Partition</em>) – The second partition.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Dissimilarity between partition first and second.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="networkit.community.LFM">
<span class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></span><span class="sig-prename descclassname"><span class="pre">networkit.community.</span></span><span class="sig-name descname"><span class="pre">LFM</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scd</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#networkit.community.LFM" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#networkit.community.OverlappingCommunityDetector" title="networkit.community.OverlappingCommunityDetector"><code class="xref py py-class docutils literal notranslate"><span class="pre">OverlappingCommunityDetector</span></code></a></p>
<p>Local community expansion algorithm:</p>
<p>The LFM algorithm detects overlapping communities by repeatedly
executing a given selective community detector algorithm
for different random seed nodes which have not yet been assigned to any community.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> (<em>networkit.Graph</em>) – The graph on which the algorithm has to run.</p></li>
<li><p><strong>scd</strong> (<a class="reference internal" href="scd.html#networkit.scd.SelectiveCommunityDetector" title="networkit.scd.SelectiveCommunityDetector"><em>networkit.scd.SelectiveCommunityDetector</em></a>) – The selective community detector algorithm which is run on
randomly selected seed nodes</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Local community expansion algorithm as introduced in:</p>
<p>Lancichinetti, A., Fortunato, S., &amp; Kertész, J. (2009).
Detecting the overlapping and hierarchical community structure in complex networks.
New Journal of Physics, 11(3), 033015.
<a class="reference external" href="https://doi.org/10.1088/1367-2630/11/3/033015">https://doi.org/10.1088/1367-2630/11/3/033015</a></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="networkit.community.LPDegreeOrdered">
<span class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></span><span class="sig-prename descclassname"><span class="pre">networkit.community.</span></span><span class="sig-name descname"><span class="pre">LPDegreeOrdered</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#networkit.community.LPDegreeOrdered" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#networkit.community.CommunityDetector" title="networkit.community.CommunityDetector"><code class="xref py py-class docutils literal notranslate"><span class="pre">CommunityDetector</span></code></a></p>
<p>Label propagation-based community detection algorithm which processes nodes in increasing order of node degree.</p>
<dl class="py method">
<dt class="sig sig-object py" id="networkit.community.LPDegreeOrdered.numberOfIterations">
<span class="sig-name descname"><span class="pre">numberOfIterations</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#networkit.community.LPDegreeOrdered.numberOfIterations" title="Link to this definition">¶</a></dt>
<dd><p>Get number of iterations in last run.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Number of iterations.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>int</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="networkit.community.LocalCommunityEvaluation">
<span class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></span><span class="sig-prename descclassname"><span class="pre">networkit.community.</span></span><span class="sig-name descname"><span class="pre">LocalCommunityEvaluation</span></span><a class="headerlink" href="#networkit.community.LocalCommunityEvaluation" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="base.html#networkit.base.Algorithm" title="networkit.base.Algorithm"><code class="xref py py-class docutils literal notranslate"><span class="pre">Algorithm</span></code></a></p>
<p>Virtual base class of all evaluation methods for a single clustering which is based on the evaluation of single clusters.
This is the base class both for Partitions as well as for Covers.</p>
<dl class="py method">
<dt class="sig sig-object py" id="networkit.community.LocalCommunityEvaluation.getMaximumValue">
<span class="sig-name descname"><span class="pre">getMaximumValue</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#networkit.community.LocalCommunityEvaluation.getMaximumValue" title="Link to this definition">¶</a></dt>
<dd><p>Get the maximum value of all clusters.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The maximum value.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="networkit.community.LocalCommunityEvaluation.getMinimumValue">
<span class="sig-name descname"><span class="pre">getMinimumValue</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#networkit.community.LocalCommunityEvaluation.getMinimumValue" title="Link to this definition">¶</a></dt>
<dd><p>Get the minimum value of all clusters.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The minimum value.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="networkit.community.LocalCommunityEvaluation.getUnweightedAverage">
<span class="sig-name descname"><span class="pre">getUnweightedAverage</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#networkit.community.LocalCommunityEvaluation.getUnweightedAverage" title="Link to this definition">¶</a></dt>
<dd><p>Get the (unweighted) average value of all clusters.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The unweighted average value.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="networkit.community.LocalCommunityEvaluation.getValue">
<span class="sig-name descname"><span class="pre">getValue</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">index</span> <span class="pre">i</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#networkit.community.LocalCommunityEvaluation.getValue" title="Link to this definition">¶</a></dt>
<dd><p>Get the value of the specified cluster.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>i</strong> (<em>int</em>) – The cluster to get the value for.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The value of cluster i.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="networkit.community.LocalCommunityEvaluation.getValues">
<span class="sig-name descname"><span class="pre">getValues</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#networkit.community.LocalCommunityEvaluation.getValues" title="Link to this definition">¶</a></dt>
<dd><p>Get the values of all clusters.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The values of all clusters.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>list(float)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="networkit.community.LocalCommunityEvaluation.getWeightedAverage">
<span class="sig-name descname"><span class="pre">getWeightedAverage</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#networkit.community.LocalCommunityEvaluation.getWeightedAverage" title="Link to this definition">¶</a></dt>
<dd><p>Get the average value weighted by cluster size.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The weighted average value.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="networkit.community.LocalCommunityEvaluation.isSmallBetter">
<span class="sig-name descname"><span class="pre">isSmallBetter</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#networkit.community.LocalCommunityEvaluation.isSmallBetter" title="Link to this definition">¶</a></dt>
<dd><p>If small values are better (otherwise large values are better).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>If small values are better.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>bool</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="networkit.community.LocalCoverEvaluation">
<span class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></span><span class="sig-prename descclassname"><span class="pre">networkit.community.</span></span><span class="sig-name descname"><span class="pre">LocalCoverEvaluation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">P</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#networkit.community.LocalCoverEvaluation" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#networkit.community.LocalCommunityEvaluation" title="networkit.community.LocalCommunityEvaluation"><code class="xref py py-class docutils literal notranslate"><span class="pre">LocalCommunityEvaluation</span></code></a></p>
<p>Virtual base class of all evaluation methods for a single clustering which is based on the evaluation of single clusters.
This is the base class for Covers.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="networkit.community.LocalPartitionEvaluation">
<span class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></span><span class="sig-prename descclassname"><span class="pre">networkit.community.</span></span><span class="sig-name descname"><span class="pre">LocalPartitionEvaluation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">P</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#networkit.community.LocalPartitionEvaluation" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#networkit.community.LocalCommunityEvaluation" title="networkit.community.LocalCommunityEvaluation"><code class="xref py py-class docutils literal notranslate"><span class="pre">LocalCommunityEvaluation</span></code></a></p>
<p>Virtual base class of all evaluation methods for a single clustering which is based on the evaluation of single clusters.
This is the base class for Partitions.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="networkit.community.LouvainMapEquation">
<span class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></span><span class="sig-prename descclassname"><span class="pre">networkit.community.</span></span><span class="sig-name descname"><span class="pre">LouvainMapEquation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hierarchical</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxIterations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">32</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parallelizationStrategy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'relaxmap'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#networkit.community.LouvainMapEquation" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#networkit.community.CommunityDetector" title="networkit.community.CommunityDetector"><code class="xref py py-class docutils literal notranslate"><span class="pre">CommunityDetector</span></code></a></p>
<p>Community detection algorithm based on the Louvain algorithm. Uses the Map Equation to find communities.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> (<em>networkit.Graph</em>) – The graph on which the algorithm has to run.</p></li>
<li><p><strong>hierarchical</strong> (<em>bool</em><em>, </em><em>optional</em>) – Iteratively create a graph of the locally optimal clusters and optimize locally on that graph.</p></li>
<li><p><strong>maxIterations</strong> (<em>int</em><em>, </em><em>optional</em>) – The maximum number of local move iterations. Default: 32</p></li>
<li><p><strong>parallelizationStrategy</strong> (<em>str</em><em>, </em><em>optional</em>) – Parallelization strategy, possible values: “relaxmap”, “synchronous”, “none”. Default: “relaxmap”</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="networkit.community.Modularity">
<span class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></span><span class="sig-prename descclassname"><span class="pre">networkit.community.</span></span><span class="sig-name descname"><span class="pre">Modularity</span></span><a class="headerlink" href="#networkit.community.Modularity" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Modularity is a quality index for community detection.
It assigns a quality value in [-0.5, 1.0] to a partition of a graph which is higher for more modular networks and
partitions which better capture the modular structure. See also <a class="reference external" href="http://en.wikipedia.org/wiki/Modularity_(networks">http://en.wikipedia.org/wiki/Modularity_(networks</a>) .</p>
<p class="rubric">Notes</p>
<p>Modularity is defined as:</p>
<div class="math notranslate nohighlight">
\[mod(\zeta) := \frac{\sum_{C \in \zeta} \sum_{ e \in E(C) } \omega(e)}{\sum_{e \in E} \omega(e)} - \frac{ \sum_{C \in \zeta}( \sum_{v \in C} \omega(v) )^2 }{4( \sum_{e \in E} \omega(e) )^2 }\]</div>
<dl class="py method">
<dt class="sig sig-object py" id="networkit.community.Modularity.getQuality">
<span class="sig-name descname"><span class="pre">getQuality</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">zeta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">G</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#networkit.community.Modularity.getQuality" title="Link to this definition">¶</a></dt>
<dd><p>Calculates the modularity in the given Partition of the given
Graph.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>zeta</strong> (<em>networkit.Partition</em>) – The Partition for which the modularity shall be calculated</p></li>
<li><p><strong>G</strong> (<em>networkit.Graph</em>) – The Graph to which zeta belongs</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The modularity in the given Partition</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="networkit.community.NMIDistance">
<span class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></span><span class="sig-prename descclassname"><span class="pre">networkit.community.</span></span><span class="sig-name descname"><span class="pre">NMIDistance</span></span><a class="headerlink" href="#networkit.community.NMIDistance" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#networkit.community.DissimilarityMeasure" title="networkit.community.DissimilarityMeasure"><code class="xref py py-class docutils literal notranslate"><span class="pre">DissimilarityMeasure</span></code></a></p>
<p>The NMI distance assigns a similarity value in [0,1] to two partitions
of a graph.</p>
<dl class="py method">
<dt class="sig sig-object py" id="networkit.community.NMIDistance.getDissimilarity">
<span class="sig-name descname"><span class="pre">getDissimilarity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">first</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">second</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#networkit.community.NMIDistance.getDissimilarity" title="Link to this definition">¶</a></dt>
<dd><p>Returns dissimilarity between two partitions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> (<em>networkit.Graph</em>) – The graph.</p></li>
<li><p><strong>first</strong> (<em>networkit.Partition</em>) – The first partition.</p></li>
<li><p><strong>second</strong> (<em>networkit.Partition</em>) – The second partition.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Dissimilarity between partition first and second.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="networkit.community.NodeStructuralRandMeasure">
<span class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></span><span class="sig-prename descclassname"><span class="pre">networkit.community.</span></span><span class="sig-name descname"><span class="pre">NodeStructuralRandMeasure</span></span><a class="headerlink" href="#networkit.community.NodeStructuralRandMeasure" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#networkit.community.DissimilarityMeasure" title="networkit.community.DissimilarityMeasure"><code class="xref py py-class docutils literal notranslate"><span class="pre">DissimilarityMeasure</span></code></a></p>
<p>The node-structural Rand measure assigns a similarity value in [0,1]
to two partitions of a graph, by considering all pairs of nodes.</p>
<dl class="py method">
<dt class="sig sig-object py" id="networkit.community.NodeStructuralRandMeasure.getDissimilarity">
<span class="sig-name descname"><span class="pre">getDissimilarity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">first</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">second</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#networkit.community.NodeStructuralRandMeasure.getDissimilarity" title="Link to this definition">¶</a></dt>
<dd><p>Returns dissimilarity between two partitions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> (<em>networkit.Graph</em>) – The input graph.</p></li>
<li><p><strong>first</strong> (<em>networkit.Partition</em>) – The first partition.</p></li>
<li><p><strong>second</strong> (<em>networkit.Partition</em>) – The second partition.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Dissimilarity between partition first and second.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="networkit.community.Normalization">
<span class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></span><span class="sig-prename descclassname"><span class="pre">networkit.community.</span></span><span class="sig-name descname"><span class="pre">Normalization</span></span><a class="headerlink" href="#networkit.community.Normalization" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="py attribute">
<dt class="sig sig-object py" id="networkit.community.Normalization.ARITHMETIC_MEAN">
<span class="sig-name descname"><span class="pre">ARITHMETIC_MEAN</span></span><span class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">2</span></span><a class="headerlink" href="#networkit.community.Normalization.ARITHMETIC_MEAN" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="networkit.community.Normalization.ArithmeticMean">
<span class="sig-name descname"><span class="pre">ArithmeticMean</span></span><span class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">2</span></span><a class="headerlink" href="#networkit.community.Normalization.ArithmeticMean" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="networkit.community.Normalization.GEOMETRIC_MEAN">
<span class="sig-name descname"><span class="pre">GEOMETRIC_MEAN</span></span><span class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">1</span></span><a class="headerlink" href="#networkit.community.Normalization.GEOMETRIC_MEAN" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="networkit.community.Normalization.GeometricMean">
<span class="sig-name descname"><span class="pre">GeometricMean</span></span><span class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">1</span></span><a class="headerlink" href="#networkit.community.Normalization.GeometricMean" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="networkit.community.Normalization.JOINT_ENTROPY">
<span class="sig-name descname"><span class="pre">JOINT_ENTROPY</span></span><span class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">4</span></span><a class="headerlink" href="#networkit.community.Normalization.JOINT_ENTROPY" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="networkit.community.Normalization.JointEntropy">
<span class="sig-name descname"><span class="pre">JointEntropy</span></span><span class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">4</span></span><a class="headerlink" href="#networkit.community.Normalization.JointEntropy" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="networkit.community.Normalization.MAX">
<span class="sig-name descname"><span class="pre">MAX</span></span><span class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">3</span></span><a class="headerlink" href="#networkit.community.Normalization.MAX" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="networkit.community.Normalization.MIN">
<span class="sig-name descname"><span class="pre">MIN</span></span><span class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">0</span></span><a class="headerlink" href="#networkit.community.Normalization.MIN" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="networkit.community.Normalization.Max">
<span class="sig-name descname"><span class="pre">Max</span></span><span class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">3</span></span><a class="headerlink" href="#networkit.community.Normalization.Max" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="networkit.community.Normalization.Min">
<span class="sig-name descname"><span class="pre">Min</span></span><span class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">0</span></span><a class="headerlink" href="#networkit.community.Normalization.Min" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="networkit.community.OverlappingCommunityDetector">
<span class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></span><span class="sig-prename descclassname"><span class="pre">networkit.community.</span></span><span class="sig-name descname"><span class="pre">OverlappingCommunityDetector</span></span><a class="headerlink" href="#networkit.community.OverlappingCommunityDetector" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="base.html#networkit.base.Algorithm" title="networkit.base.Algorithm"><code class="xref py py-class docutils literal notranslate"><span class="pre">Algorithm</span></code></a></p>
<p>Abstract base class for static overlapping community detection algorithms.</p>
<dl class="py method">
<dt class="sig sig-object py" id="networkit.community.OverlappingCommunityDetector.getCover">
<span class="sig-name descname"><span class="pre">getCover</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#networkit.community.OverlappingCommunityDetector.getCover" title="Link to this definition">¶</a></dt>
<dd><p>Returns a cover of the clustering.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A Cover of the clustering.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>networkit.Cover</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="networkit.community.OverlappingNMIDistance">
<span class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></span><span class="sig-prename descclassname"><span class="pre">networkit.community.</span></span><span class="sig-name descname"><span class="pre">OverlappingNMIDistance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">normalization</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">networkit.community.Normalization.MAX</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#networkit.community.OverlappingNMIDistance" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#networkit.community.DissimilarityMeasure" title="networkit.community.DissimilarityMeasure"><code class="xref py py-class docutils literal notranslate"><span class="pre">DissimilarityMeasure</span></code></a></p>
<p>Compare two covers using the overlapping normalized mutual information measure. This is a dissimilarity measure with
a range of [0, 1]. A value of 0 indicates a perfect agreement while a 1 indicates complete disagreement.</p>
<p>For <cite>networkit.community.Normalization.Max</cite> normalization, this is the measure introduced in [NMI13]. Other normalization
methods result in similar measures.</p>
<p>Parameter <code class="code docutils literal notranslate"><span class="pre">normalization</span></code> can be one of the following:</p>
<ul class="simple">
<li><p>networkit.community.Normalization.MIN</p></li>
<li><p>networkit.community.Normalization.GEOMETRIC_MEAN</p></li>
<li><p>networkit.community.Normalization.ARITHMETIC_MEAN</p></li>
<li><p>networkit.community.Normalization.MAX</p></li>
<li><p>networkit.community.Normalization.JOINT_ENTROPY</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>normalization</strong> (<a class="reference internal" href="#networkit.community.Normalization" title="networkit.community.Normalization"><em>networkit.community.Normalization</em></a><em>, </em><em>optional</em>) – Normalization strategy for OverlappingNMIDistance. Default: networkit.community.Normalization.MAX</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – If <cite>normalization</cite> is not one of the available methods.</p>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="simple">
<dt>[NMI13]</dt><dd><p>McDaid, Aaron F., Derek Greene, and Neil Hurley. “Normalized Mutual Information to Evaluate Overlapping
Community Finding Algorithms.” ArXiv:1110.2515 [Physics], August 2, 2013. http://arxiv.org/abs/1110.2515.</p>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="networkit.community.OverlappingNMIDistance.getDissimilarity">
<span class="sig-name descname"><span class="pre">getDissimilarity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">first</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">second</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#networkit.community.OverlappingNMIDistance.getDissimilarity" title="Link to this definition">¶</a></dt>
<dd><p>Calculate the dissimilarity.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> (<em>networkit.Graph</em>) – The input graph.</p></li>
<li><p><strong>first</strong> (<em>networkit.Partition</em><em> or </em><em>networkit.Cover</em>) – The first input partition/cover.</p></li>
<li><p><strong>second</strong> (<em>networkit.Partition</em><em> or </em><em>networkit.Cover</em>) – The second input partition/cover. Must be the same type as <cite>first</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>TypeError</strong> – If <cite>first</cite> and <cite>second</cite> do not have the same type.</p></li>
<li><p><strong>ValueError</strong> – If <cite>G</cite>, <cite>first</cite> and <cite>second</cite> do not have the matching number of nodes.</p></li>
</ul>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Resulting overlapping NMI distance.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="networkit.community.OverlappingNMIDistance.setNormalization">
<span class="sig-name descname"><span class="pre">setNormalization</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalization</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#networkit.community.OverlappingNMIDistance.setNormalization" title="Link to this definition">¶</a></dt>
<dd><p>Set the normalization method.</p>
<p>Parameter <code class="code docutils literal notranslate"><span class="pre">normalization</span></code> can be one of the following:</p>
<ul class="simple">
<li><p>networkit.community.Normalization.MIN</p></li>
<li><p>networkit.community.Normalization.GEOMETRIC_MEAN</p></li>
<li><p>networkit.community.Normalization.ARITHMETIC_MEAN</p></li>
<li><p>networkit.community.Normalization.MAX</p></li>
<li><p>networkit.community.Normalization.JOINT_ENTROPY</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>normalization</strong> (<a class="reference internal" href="#networkit.community.Normalization" title="networkit.community.Normalization"><em>networkit.community.Normalization</em></a>) – Normalization strategy for OverlappingNMIDistance.</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – If <cite>normalization</cite> is not one of the available methods.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="networkit.community.PLM">
<span class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></span><span class="sig-prename descclassname"><span class="pre">networkit.community.</span></span><span class="sig-name descname"><span class="pre">PLM</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">refine</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gamma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">par</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'balanced'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxIter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">32</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">turbo</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">recurse</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#networkit.community.PLM" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#networkit.community.CommunityDetector" title="networkit.community.CommunityDetector"><code class="xref py py-class docutils literal notranslate"><span class="pre">CommunityDetector</span></code></a></p>
<p>Parallel Louvain Method - the Louvain method, optionally extended to
a full multi-level algorithm with refinement.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> (<em>networkit.Graph</em>) – The input graph.</p></li>
<li><p><strong>refine</strong> (<em>bool</em><em>, </em><em>optional</em>) – Add a second move phase to refine the communities. Default: False</p></li>
<li><p><strong>gamma</strong> (<em>float</em><em>, </em><em>optional</em>) – Multi-resolution modularity parameter: 1.0 (standard modularity), 0.0 (one community), 2m (singleton communities). Default: 1.0</p></li>
<li><p><strong>par</strong> (<em>str</em><em>, </em><em>optional</em>) – Parallelization strategy, possible values: “none”, “simple”, “balanced”, “none randomized”. Default “balanced”</p></li>
<li><p><strong>maxIter</strong> (<em>int</em><em>, </em><em>optional</em>) – Maximum number of iterations for move phase. Default: 32</p></li>
<li><p><strong>turbo</strong> (<em>bool</em><em>, </em><em>optional</em>) – Faster but uses O(n) additional memory per thread. Default: True</p></li>
<li><p><strong>recurse</strong> (<em>bool</em><em>, </em><em>optional</em>) – Use recursive coarsening, see <a class="reference external" href="http://journals.aps.org/pre/abstract/10.1103/PhysRevE.89.049902">http://journals.aps.org/pre/abstract/10.1103/PhysRevE.89.049902</a> for some explanations.
Default: True</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="networkit.community.PLM.coarsen">
<span class="property"><span class="k"><span class="pre">static</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">coarsen</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zeta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parallel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#networkit.community.PLM.coarsen" title="Link to this definition">¶</a></dt>
<dd><p>Coarsens a graph based on a given partition and returns both the coarsened graph and a mapping
for the nodes from fine to coarse.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> (<em>networkit.Graph</em>) – The input graph.</p></li>
<li><p><strong>zeta</strong> (<em>networkit.Partition</em>) – Partition of the graph, which represents the desired state of the coarsened graph.</p></li>
<li><p><strong>parallel</strong> (<em>bool</em><em>, </em><em>optional</em>) – Do the coarsening in parallel. Default: False</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Pair of coarsened graph and node-mappings from fine to coarse graph.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>networkit.Graph</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="networkit.community.PLM.getTiming">
<span class="sig-name descname"><span class="pre">getTiming</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#networkit.community.PLM.getTiming" title="Link to this definition">¶</a></dt>
<dd><p>Get detailed time measurements.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Time for computing PLM.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="networkit.community.PLM.prolong">
<span class="property"><span class="k"><span class="pre">static</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">prolong</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Gcoarse</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zetaCoarse</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Gfine</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nodeToMetaNode</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#networkit.community.PLM.prolong" title="Link to this definition">¶</a></dt>
<dd><p>Calculates a partition containing the mapping of node-id from a fine graph
to a cluster-id from partition based on a coarse graph.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Gcoarse</strong> (<em>networkit.Graph</em>) – A coarse graph.</p></li>
<li><p><strong>zetaCoarse</strong> (<em>networkit.Partition</em>) – The first partition.</p></li>
<li><p><strong>Gfine</strong> (<em>networkit.Graph</em>) – A fine graph.</p></li>
<li><p><strong>nodeToMetaNode</strong> (<em>list</em><em>(</em><em>int</em><em>)</em>) – Partition, which contains the cluster-id in the coarse graph for every node from the fine graph.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Output partition.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>networkit.Partition</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="networkit.community.PLP">
<span class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></span><span class="sig-prename descclassname"><span class="pre">networkit.community.</span></span><span class="sig-name descname"><span class="pre">PLP</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">updateThreshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxIterations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">baseClustering</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#networkit.community.PLP" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#networkit.community.CommunityDetector" title="networkit.community.CommunityDetector"><code class="xref py py-class docutils literal notranslate"><span class="pre">CommunityDetector</span></code></a></p>
<p>Parallel label propagation for community detection:
Moderate solution quality, very short time to solution.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> (<em>networkit.Graph</em>) – The graph on which the algorithm has to run.</p></li>
<li><p><strong>updateThreshold</strong> (<em>int</em><em>, </em><em>optional</em>) – number of nodes that have to be changed in each iteration so that a new iteration starts. Default: None</p></li>
<li><p><strong>maxIterations</strong> (<em>int</em><em>, </em><em>optional</em>) – The maximum number of local move iterations. Default: None</p></li>
<li><p><strong>baseClustering</strong> (<em>networkit.Partition</em><em>, </em><em>optional</em>) – PLP needs a base clustering to start from; if none is given the algorithm will
run on a singleton clustering. Default: None</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>As described in Ovelgoenne et al: An Ensemble Learning Strategy for Graph Clustering
Raghavan et al. proposed a label propagation algorithm for graph clustering.
This algorithm initializes every vertex of a graph with a unique label. Then, in iterative
sweeps over the set of vertices the vertex labels are updated. A vertex gets the label
that the maximum number of its neighbors have. The procedure is stopped when every vertex
has the label that at least half of its neighbors have.</p>
<dl class="py method">
<dt class="sig sig-object py" id="networkit.community.PLP.getTiming">
<span class="sig-name descname"><span class="pre">getTiming</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#networkit.community.PLP.getTiming" title="Link to this definition">¶</a></dt>
<dd><p>Get list of running times for each iteration.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The list of running times in milliseconds.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="networkit.community.PLP.numberOfIterations">
<span class="sig-name descname"><span class="pre">numberOfIterations</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#networkit.community.PLP.numberOfIterations" title="Link to this definition">¶</a></dt>
<dd><p>Get number of iterations in last run.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The number of iterations.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>int</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="networkit.community.ParallelLeiden">
<span class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></span><span class="sig-prename descclassname"><span class="pre">networkit.community.</span></span><span class="sig-name descname"><span class="pre">ParallelLeiden</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">randomize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">iterations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gamma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#networkit.community.ParallelLeiden" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#networkit.community.CommunityDetector" title="networkit.community.CommunityDetector"><code class="xref py py-class docutils literal notranslate"><span class="pre">CommunityDetector</span></code></a></p>
<p>Parallel Leiden Algorithm.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> (<em>networkit.Graph</em>) – A graph.</p></li>
<li><p><strong>randomize</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to randomize the node order or not. Default: True</p></li>
<li><p><strong>iterations</strong> (<em>int</em><em>, </em><em>optional</em>) – Maximum count of Leiden runs. Default: 3</p></li>
<li><p><strong>gamma</strong> (<em>float</em><em>, </em><em>optional</em>) – Multi-resolution modularity parameter: 1.0 (standard modularity), 0.0 (one community), 2m (singleton communities). Default: 1.0</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="networkit.community.PartitionFragmentation">
<span class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></span><span class="sig-prename descclassname"><span class="pre">networkit.community.</span></span><span class="sig-name descname"><span class="pre">PartitionFragmentation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">P</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#networkit.community.PartitionFragmentation" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#networkit.community.LocalPartitionEvaluation" title="networkit.community.LocalPartitionEvaluation"><code class="xref py py-class docutils literal notranslate"><span class="pre">LocalPartitionEvaluation</span></code></a></p>
<p>This measure evaluates how fragmented a partition is. The fragmentation of a single cluster is defined as one minus the
number of nodes in its maximum connected componented divided by its total number of nodes. Smaller values thus indicate a smaller fragmentation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> (<em>networkit.Graph</em>) – The graph on which the measure shall be evaluated.</p></li>
<li><p><strong>P</strong> (<em>networkit.Partition</em>) – The partition that shall be evaluated.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="networkit.community.PartitionHubDominance">
<span class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></span><span class="sig-prename descclassname"><span class="pre">networkit.community.</span></span><span class="sig-name descname"><span class="pre">PartitionHubDominance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">P</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#networkit.community.PartitionHubDominance" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#networkit.community.LocalPartitionEvaluation" title="networkit.community.LocalPartitionEvaluation"><code class="xref py py-class docutils literal notranslate"><span class="pre">LocalPartitionEvaluation</span></code></a></p>
<p>A quality measure that measures the dominance of hubs in clusters. The hub dominance of a single
cluster is defined as the maximum cluster-internal degree of a node in that cluster divided by
the maximum cluster-internal degree, i.e. the number of nodes in the cluster minus one. The
value for all clusters is defined as the average of all clusters.
Strictly speaking this is not a quality measure as this is rather dependent on the type of the
considered graph, for more information see
Lancichinetti A, Kivel M, Saramki J, Fortunato S (2010)
Characterizing the Community Structure of Complex Networks
PLoS ONE 5(8): e11976. doi: 10.1371/journal.pone.0011976
<a class="reference external" href="http://www.plosone.org/article/info%3Adoi%2F10.1371%2Fjournal.pone.0011976">http://www.plosone.org/article/info%3Adoi%2F10.1371%2Fjournal.pone.0011976</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> (<em>networkit.Graph</em>) – The graph on which the measure shall be evaluated.</p></li>
<li><p><strong>P</strong> (<em>networkit.Partition</em>) – The partition that shall be evaluated.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="networkit.community.PartitionIntersection">
<span class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></span><span class="sig-prename descclassname"><span class="pre">networkit.community.</span></span><span class="sig-name descname"><span class="pre">PartitionIntersection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">zeta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eta</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#networkit.community.PartitionIntersection" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Class for calculating the intersection of two partitions, i.e. the clustering with the fewest clusters
such that each cluster is a subset of a cluster in both partitions.</p>
<dl class="py method">
<dt class="sig sig-object py" id="networkit.community.PartitionIntersection.calculate">
<span class="sig-name descname"><span class="pre">calculate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">zeta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eta</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#networkit.community.PartitionIntersection.calculate" title="Link to this definition">¶</a></dt>
<dd><p>Calculate the intersection of two partitions <cite>zeta</cite> and <cite>eta</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>zeta</strong> (<em>networkit.Partition</em>) – The first partition.</p></li>
<li><p><strong>eta</strong> (<em>networkit.Partition</em>) – The second partition.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The intersection of zeta and eta.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>networkit.Partition</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="networkit.community.SpectralPartitioner">
<span class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></span><span class="sig-prename descclassname"><span class="pre">networkit.community.</span></span><span class="sig-name descname"><span class="pre">SpectralPartitioner</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">graph</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">count</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">balances</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#networkit.community.SpectralPartitioner" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Class to do spectral partitioning.</p>
<p>Please note that the code in this class assumes the nodes of a graph to be numbered
from 0 to n.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>graph</strong> (<em>networkit.Graph</em>) – The input graph.</p></li>
<li><p><strong>count</strong> (<em>int</em>) – The number of partitions to create.</p></li>
<li><p><strong>balanced</strong> (<em>bool</em><em>, </em><em>optional</em>) – Set this to false if you do not want to enforce balance, possibly increasing quality. Default: True</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="networkit.community.SpectralPartitioner.getPartition">
<span class="sig-name descname"><span class="pre">getPartition</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#networkit.community.SpectralPartitioner.getPartition" title="Link to this definition">¶</a></dt>
<dd><p>Retrieves the partitioning after run() was called.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The resulting partition. Only valid if <code class="code docutils literal notranslate"><span class="pre">run()</span></code> was called before.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>networkit.Partition</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="networkit.community.SpectralPartitioner.run">
<span class="sig-name descname"><span class="pre">run</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#networkit.community.SpectralPartitioner.run" title="Link to this definition">¶</a></dt>
<dd><p>Runs the partitioning.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="networkit.community.StablePartitionNodes">
<span class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></span><span class="sig-prename descclassname"><span class="pre">networkit.community.</span></span><span class="sig-name descname"><span class="pre">StablePartitionNodes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">P</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#networkit.community.StablePartitionNodes" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#networkit.community.LocalPartitionEvaluation" title="networkit.community.LocalPartitionEvaluation"><code class="xref py py-class docutils literal notranslate"><span class="pre">LocalPartitionEvaluation</span></code></a></p>
<p>Evaluates how stable a given partition is. A node is considered to be stable if it has strictly more connections
to its own partition than to other partitions. Isolated nodes are considered to be stable.
The value of a cluster is the percentage of stable nodes in the cluster.
Larger values indicate that a clustering is more stable and thus better defined.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> (<em>networkit.Graph</em>) – The graph on which the measure shall be evaluated.</p></li>
<li><p><strong>P</strong> (<em>networkit.Partition</em>) – The partition that shall be evaluated.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="networkit.community.StablePartitionNodes.isStable">
<span class="sig-name descname"><span class="pre">isStable</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">u</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#networkit.community.StablePartitionNodes.isStable" title="Link to this definition">¶</a></dt>
<dd><p>Check if a given node is stable, i.e. more connected to its own partition than to other partitions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>u</strong> (<em>int</em>) – The node to check.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>If the node u is stable.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="networkit.community.communityGraph">
<span class="sig-prename descclassname"><span class="pre">networkit.community.</span></span><span class="sig-name descname"><span class="pre">communityGraph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">P</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#networkit.community.communityGraph" title="Link to this definition">¶</a></dt>
<dd><p>Create a community graph, i.e. a graph in which one node represents a community and an edge represents the edges
between communities, from a given graph and a community detection solution.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> (<em>networkit.Graph</em>) – The graph on which the evaluation is performed.</p></li>
<li><p><strong>P</strong> (<em>networkit.Partition</em>) – The input Partition.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="networkit.community.compareCommunities">
<span class="sig-prename descclassname"><span class="pre">networkit.community.</span></span><span class="sig-name descname"><span class="pre">compareCommunities</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zeta1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zeta2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#networkit.community.compareCommunities" title="Link to this definition">¶</a></dt>
<dd><p>Compare the partitions with respect to several (dis)similarity measures.</p>
<p class="rubric">Notes</p>
<p>Currently not implemented.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="networkit.community.detectCommunities">
<span class="sig-prename descclassname"><span class="pre">networkit.community.</span></span><span class="sig-name descname"><span class="pre">detectCommunities</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">algo</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inspect</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#networkit.community.detectCommunities" title="Link to this definition">¶</a></dt>
<dd><p>Perform high-performance community detection on the graph.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> (<a class="reference internal" href="graph.html#networkit.graph.Graph" title="networkit.graph.Graph"><em>Graph</em></a>) – The graph on which the evaluation is performed.</p></li>
<li><p><strong>algo</strong> (<a class="reference internal" href="#networkit.community.CommunityDetector" title="networkit.community.CommunityDetector"><em>networkit.community.CommunityDetector</em></a>) – Community detection algorithm instance. Default: None</p></li>
<li><p><strong>inspect</strong> (<em>bool</em><em>, </em><em>optional</em>) – Print properties of the found solution. Default: True</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Return communities (as type Partition).</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>networkit.Partition</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="networkit.community.evalCommunityDetection">
<span class="sig-prename descclassname"><span class="pre">networkit.community.</span></span><span class="sig-name descname"><span class="pre">evalCommunityDetection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">algo</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">G</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#networkit.community.evalCommunityDetection" title="Link to this definition">¶</a></dt>
<dd><p>Evaluate a community detection algorithm</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>algo</strong> (<a class="reference internal" href="#networkit.community.CommunityDetector" title="networkit.community.CommunityDetector"><em>networkit.community.CommunityDetector</em></a>) – Community detection algorithm instance</p></li>
<li><p><strong>G</strong> (<em>networkit.Graph</em>) – The graph on which the evaluation is performed.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>inspection of communities (needs external tabulate-module)</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tabulate.tabulate</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="networkit.community.inspectCommunities">
<span class="sig-prename descclassname"><span class="pre">networkit.community.</span></span><span class="sig-name descname"><span class="pre">inspectCommunities</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">zeta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">G</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#networkit.community.inspectCommunities" title="Link to this definition">¶</a></dt>
<dd><p>Display information about communities.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>zeta</strong> (<em>networkit.Partition</em>) – The input Partition.</p></li>
<li><p><strong>G</strong> (<em>networkit.Graph</em>) – The graph on which the evaluation is performed.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>inspection of communities (needs external tabulate-module)</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tabulate.tabulate</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="networkit.community.kCoreCommunityDetection">
<span class="sig-prename descclassname"><span class="pre">networkit.community.</span></span><span class="sig-name descname"><span class="pre">kCoreCommunityDetection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">algo</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inspect</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#networkit.community.kCoreCommunityDetection" title="Link to this definition">¶</a></dt>
<dd><p>Perform community detection on the k-core of the graph, which possibly</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> (<em>networkit.Graph</em>) – The graph on which the evaluation is performed.</p></li>
<li><p><strong>k</strong> (<em>float</em>) – Set k as used in k-core.</p></li>
<li><p><strong>algo</strong> (<a class="reference internal" href="#networkit.community.CommunityDetector" title="networkit.community.CommunityDetector"><em>networkit.community.CommunityDetector</em></a><em>, </em><em>optional</em>) – Community detection algorithm instance. Default: None</p></li>
<li><p><strong>inspect</strong> (<em>bool</em><em>, </em><em>optional</em>) – Print properties of the found solution. Default: True</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Return communities (as type Partition).</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>networkit.Partition</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="networkit.community.readCommunities">
<span class="sig-prename descclassname"><span class="pre">networkit.community.</span></span><span class="sig-name descname"><span class="pre">readCommunities</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'default'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#networkit.community.readCommunities" title="Link to this definition">¶</a></dt>
<dd><p>Read a partition into communities from a file</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>path</strong> (<em>str</em>) – Path to file, which contains information about communities.</p></li>
<li><p><strong>format</strong> (<em>str</em><em>, </em><em>optional</em>) – Format from file, possible values: “default”, “edgelist-t1”, “edgelist-t0”, “edgelist-s1”, “edgelist-s0”. Default: “default”</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="networkit.community.writeCommunities">
<span class="sig-prename descclassname"><span class="pre">networkit.community.</span></span><span class="sig-name descname"><span class="pre">writeCommunities</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">communities</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#networkit.community.writeCommunities" title="Link to this definition">¶</a></dt>
<dd><p>Write a partition into communities to a file</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>communities</strong> (<em>networkit.Partition</em>) – The input communities.</p></li>
<li><p><strong>path</strong> (<em>str</em>) – Path to write the file to.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</section>


    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
        <br/>
        
      
    </p>
    <p style="float:left; max-width: 70%;">
        &copy; Copyright 2018 Humboldt-Universität zu Berlin - Department of Computer Science - Modeling and Analysis of Complex Systems and contributors.<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 9.1.0.<br/>
    </p>
    <span style="padding-left: 10px">
      <a href="https://networkit.github.io/contact.html">Contact, Imprint and Privacy</a>
    </span>
  </div>
</footer>
  </body>
</html>