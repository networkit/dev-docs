
<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>networkit.randomization</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../_static/bootstrap-sphinx.css?v=fa2d15c4" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery.css?v=d2d258e8" />
    <link rel="stylesheet" type="text/css" href="../_static/bootstrap-treeview/bootstrap-treeview.min.css?v=8176a87d" />
    <link rel="stylesheet" href="../_static/style.css" type="text/css" />
    <script src="../_static/documentation_options.js?v=89fba709"></script>
    <script src="../_static/doctools.js?v=fd6eb6e6"></script>
    <script src="../_static/sphinx_highlight.js?v=6ffebe34"></script>
    <script src="../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../_static/copybutton.js?v=f281be69"></script>
    <script src="../_static/bootstrap-treeview/bootstrap-treeview.min.js?v=6a1e96b4"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@^1.0.1/dist/embed-amd.js"></script>
    <script src="../_static/particles.min.js"></script>
    <script src="../_static/custom.js"></script>
    <script src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="networkit.reachability" href="reachability.html" />
    <link rel="prev" title="networkit.profiling" href="profiling.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">
<script type="text/javascript" src="../_static/js/jquery-1.12.4.min.js"></script>
<script type="text/javascript" src="../_static/js/jquery-fix.js"></script>
<script type="text/javascript" src="../_static/bootstrap-3.4.1/js/bootstrap.min.js"></script>
<script type="text/javascript" src="../_static/bootstrap-sphinx.js"></script>

  </head><body>
  
  <a href="https://github.com/networkit/networkit"
     class="visible-desktop hidden-xs"><img style="position: absolute; width:auto; height: auto; max-width: 200px; top:
     0px; right: 0; border: 0; z-index: 3;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_white_ffffff.png" alt="Fork me on GitHub"></a>  


     <div id="fancy-particles-small"></div>
  <div id="navbar" class="navbar navbar-default ">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>

        <div style="float:left;height:auto; line-height:30px;">
          <div style="overflow:hidden; line-height:15px">
              <span style="display:block">
                <a style="text-decoration: none; padding-top: 19.5px; padding-left:15px; height:30px;" class="navbar-brand" href="https://networkit.github.io">
                  NetworKit</a>
              </span>
              <div style="font-size:9pt; clear:left;">Large-Scale Network Analysis</div>              
          </div>
        </div>
      </div>



        <div id="main-nav" class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="https://networkit.github.io/get_started.html">Get Started</a></li>
                <li><a href="../index.html">Documentation</a></li>
                <li><a href="https://networkit.github.io/features.html">Features</a></li>
                <li><a href="https://networkit.github.io/news.html">News</a></li>
                <li><a href="https://networkit.github.io/publications.html">Publications</a></li>
                <li><a href="https://networkit.github.io/networkit-day.html">NetworKit Day</a></li>
                <li><a href="https://networkit.github.io/credits.html">Credits & References</a></li>
            
            
              
            
            
            
            
            
          </ul>
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
      <div class="col-md-3">
        <div id="sidebar" class="bs-sidenav" role="complementary"><ul class="sidebar">
	<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="modules.html">Python Documentation</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="modules.html#modules">Modules</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="networkit.html">networkit</a></li>
<li class="toctree-l3"><a class="reference internal" href="algebraic.html">networkit.algebraic</a></li>
<li class="toctree-l3"><a class="reference internal" href="base.html">networkit.base</a></li>
<li class="toctree-l3"><a class="reference internal" href="centrality.html">networkit.centrality</a></li>
<li class="toctree-l3"><a class="reference internal" href="clique.html">networkit.clique</a></li>
<li class="toctree-l3"><a class="reference internal" href="coarsening.html">networkit.coarsening</a></li>
<li class="toctree-l3"><a class="reference internal" href="coloring.html">networkit.coloring</a></li>
<li class="toctree-l3"><a class="reference internal" href="community.html">networkit.community</a></li>
<li class="toctree-l3"><a class="reference internal" href="components.html">networkit.components</a></li>
<li class="toctree-l3"><a class="reference internal" href="correlation.html">networkit.correlation</a></li>
<li class="toctree-l3"><a class="reference internal" href="distance.html">networkit.distance</a></li>
<li class="toctree-l3"><a class="reference internal" href="dynamic.html">networkit.dynamic</a></li>
<li class="toctree-l3"><a class="reference internal" href="dynamics.html">networkit.dynamics</a></li>
<li class="toctree-l3"><a class="reference internal" href="dynbase.html">networkit.dynbase</a></li>
<li class="toctree-l3"><a class="reference internal" href="embedding.html">networkit.embedding</a></li>
<li class="toctree-l3"><a class="reference internal" href="engineering.html">networkit.engineering</a></li>
<li class="toctree-l3"><a class="reference internal" href="flow.html">networkit.flow</a></li>
<li class="toctree-l3"><a class="reference internal" href="generators.html">networkit.generators</a></li>
<li class="toctree-l3"><a class="reference internal" href="gephi.html">networkit.gephi</a></li>
<li class="toctree-l3"><a class="reference internal" href="globals.html">networkit.globals</a></li>
<li class="toctree-l3"><a class="reference internal" href="graph.html">networkit.graph</a></li>
<li class="toctree-l3"><a class="reference internal" href="graphio.html">networkit.graphio</a></li>
<li class="toctree-l3"><a class="reference internal" href="graphtools.html">networkit.graphtools</a></li>
<li class="toctree-l3"><a class="reference internal" href="helpers.html">networkit.helpers</a></li>
<li class="toctree-l3"><a class="reference internal" href="independentset.html">networkit.independentset</a></li>
<li class="toctree-l3"><a class="reference internal" href="linkprediction.html">networkit.linkprediction</a></li>
<li class="toctree-l3"><a class="reference internal" href="matching.html">networkit.matching</a></li>
<li class="toctree-l3"><a class="reference internal" href="nxadapter.html">networkit.nxadapter</a></li>
<li class="toctree-l3"><a class="reference internal" href="plot.html">networkit.plot</a></li>
<li class="toctree-l3"><a class="reference internal" href="profiling.html">networkit.profiling</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">networkit.randomization</a></li>
<li class="toctree-l3"><a class="reference internal" href="reachability.html">networkit.reachability</a></li>
<li class="toctree-l3"><a class="reference internal" href="scd.html">networkit.scd</a></li>
<li class="toctree-l3"><a class="reference internal" href="simulation.html">networkit.simulation</a></li>
<li class="toctree-l3"><a class="reference internal" href="sparsification.html">networkit.sparsification</a></li>
<li class="toctree-l3"><a class="reference internal" href="stats.html">networkit.stats</a></li>
<li class="toctree-l3"><a class="reference internal" href="structures.html">networkit.structures</a></li>
<li class="toctree-l3"><a class="reference internal" href="traversal.html">networkit.traversal</a></li>
<li class="toctree-l3"><a class="reference internal" href="viz.html">networkit.viz</a></li>
<li class="toctree-l3"><a class="reference internal" href="vizbridges.html">networkit.vizbridges</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../cpp_api/library_root.html">C++ Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../notebooks.html">Jupyter Notebook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../DevGuide.html">Developer Guide</a></li>
</ul>

</ul>
  
<form action="../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
        </div>
      </div>
    <div class="col-md-9 content">
      
  <section id="module-networkit.randomization">
<span id="networkit-randomization"></span><h1>networkit.randomization<a class="headerlink" href="#module-networkit.randomization" title="Link to this heading">¶</a></h1>
<dl class="py class">
<dt class="sig sig-object py" id="networkit.randomization.Curveball">
<span class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></span><span class="sig-prename descclassname"><span class="pre">networkit.randomization.</span></span><span class="sig-name descname"><span class="pre">Curveball</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#networkit.randomization.Curveball" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="base.html#networkit.base.Algorithm" title="networkit.base.Algorithm"><code class="xref py py-class docutils literal notranslate"><span class="pre">Algorithm</span></code></a></p>
<p>Implementation of IM-CB proposed in “Parallel and I/O-efficient
Randomisation of Massive Networks using Global Curveball Trades”,
Carstens et al., ESA 2018.</p>
<p>The algorithm perturbs an undirected and unweighted input graph,
by iteratively randomizing the neighbourhoods of node pairs. For
a large number of trades this process is shown to produce an
uniform sample from the set of all graphs with the same degree
sequence as the input graph.</p>
<p>If you do not want to explicitly control the trade sequence,
we recommend using GlobalCurveball rather than Curveball since
GlobalCurveball is typically faster and exhibits a smaller memory
footprint.</p>
<p>Observe that this algorithm does not support the run() method,
since it requires the trade sequence to be passed. It is possible
to invoke run(trades) several times, e.g. to reduce the memory
footprint which increases linearly with the number of trades
performed in a run.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>G</strong> (<em>networkit.Graph</em>) – The graph to be randomized. For a given degree sequence, e.g.
generators.HavelHakimi can be used to obtain this graph.</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="networkit.randomization.Curveball.getGraph">
<span class="sig-name descname"><span class="pre">getGraph</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#networkit.randomization.Curveball.getGraph" title="Link to this definition">¶</a></dt>
<dd><p>Get randomized graph after invocation of run().</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The randomized graph.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>networkit.Graph</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="networkit.randomization.Curveball.getNumberOfAffectedEdges">
<span class="sig-name descname"><span class="pre">getNumberOfAffectedEdges</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#networkit.randomization.Curveball.getNumberOfAffectedEdges" title="Link to this definition">¶</a></dt>
<dd><p>Return number of affected edges.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Number of edges affected by randomization.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="networkit.randomization.Curveball.run">
<span class="sig-name descname"><span class="pre">run</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">trades</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#networkit.randomization.Curveball.run" title="Link to this definition">¶</a></dt>
<dd><p>Compute the randomization of the input by given node pairs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>trades</strong> (<em>list</em><em>(</em><em>tuple</em><em>(</em><em>int</em><em>, </em><em>int</em><em>)</em><em>)</em>) – List of pairs of nodes used for randomization of the graph.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="networkit.randomization.CurveballGlobalTradeGenerator">
<span class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></span><span class="sig-prename descclassname"><span class="pre">networkit.randomization.</span></span><span class="sig-name descname"><span class="pre">CurveballGlobalTradeGenerator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num_global_trades</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_nodes</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#networkit.randomization.CurveballGlobalTradeGenerator" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Generates a trade sequence consisting of num_global_trades global trades
targeting node ids from the range [0, num_nods).</p>
<p>If you are only using this generator, consider using the GlobalCurveball
algorithm directly as it has a better performance / memory footprint.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>num_global_trades</strong> (<em>int</em>) – Number of global trades to generate (i.e. the resulting sequence contains
num_global_trades * floor(num_nodes / 2) trades)</p></li>
<li><p><strong>num_nodes</strong> (<em>int</em>) – Number of node indices to draw from</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="networkit.randomization.CurveballGlobalTradeGenerator.generate">
<span class="sig-name descname"><span class="pre">generate</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#networkit.randomization.CurveballGlobalTradeGenerator.generate" title="Link to this definition">¶</a></dt>
<dd><p>Generate randomized graph.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The randomized graph.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>networkit.Graph</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="networkit.randomization.CurveballUniformTradeGenerator">
<span class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></span><span class="sig-prename descclassname"><span class="pre">networkit.randomization.</span></span><span class="sig-name descname"><span class="pre">CurveballUniformTradeGenerator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num_trades</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_nodes</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#networkit.randomization.CurveballUniformTradeGenerator" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Generates a trade sequence consisting of num_trades many single trades.
Each trade contains two different node indices drawn uniformly at random
from the interval [0, num_nodes).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>num_trades</strong> (<em>int</em>) – Number of trades to generate.</p></li>
<li><p><strong>num_nodes</strong> (<em>int</em>) – Number of node indices to draw from</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="networkit.randomization.CurveballUniformTradeGenerator.generate">
<span class="sig-name descname"><span class="pre">generate</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#networkit.randomization.CurveballUniformTradeGenerator.generate" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="networkit.randomization.DegreePreservingShuffle">
<span class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></span><span class="sig-prename descclassname"><span class="pre">networkit.randomization.</span></span><span class="sig-name descname"><span class="pre">DegreePreservingShuffle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#networkit.randomization.DegreePreservingShuffle" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="base.html#networkit.base.Algorithm" title="networkit.base.Algorithm"><code class="xref py py-class docutils literal notranslate"><span class="pre">Algorithm</span></code></a></p>
<p>Implementation of the preprocessing step proposed in
“Smaller Universes for Uniform Sampling of 0,1-matrices with fixed row and column sums”
by Annabell Berger, Corrie Jacobien Carstens [<a class="reference external" href="https://arxiv.org/abs/1803.02624">https://arxiv.org/abs/1803.02624</a>]</p>
<p>The algorithms randomizes a graph without changing its topology simply
by renaming nodes. For any degree d (in case of an directed graph it’s a degree pair)
consider the set X_d of node ids which have this degree. Then shuffle the ids in X_d.</p>
<p>Hence the algorithm satisfies: For all x in Ginput:</p>
<ol class="arabic simple">
<li><p>Ginput.degreeIn(x) = Goutput.degreeIn(x)</p></li>
<li><p>Ginput.degreeOut(x) = Goutput.degreeOut(x)</p></li>
</ol>
<p>The authors argue that applying this preprocessing step before executing (Global)Curveball
leads to a faster mixing time. If you want to use it as a preprocessing step to GlobalCurveball,
it’s more efficient to set degreePreservingShufflePreprocessing in GlobalCurveball’s constructor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>G</strong> (<em>networkit.Graph</em>) – The graph to be randomized. For a given degree sequence, e.g.
generators.HavelHakimi can be used to obtain this graph.</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="networkit.randomization.DegreePreservingShuffle.getGraph">
<span class="sig-name descname"><span class="pre">getGraph</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#networkit.randomization.DegreePreservingShuffle.getGraph" title="Link to this definition">¶</a></dt>
<dd><p>Get randomized graph after invocation of run().</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The randomized graph.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>networkit.Graph</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="networkit.randomization.DegreePreservingShuffle.getPermutation">
<span class="sig-name descname"><span class="pre">getPermutation</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#networkit.randomization.DegreePreservingShuffle.getPermutation" title="Link to this definition">¶</a></dt>
<dd><p>Returns the permutation used for shuffling.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>List of nodes.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>list(int)</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="networkit.randomization.EdgeSwitching">
<span class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></span><span class="sig-prename descclassname"><span class="pre">networkit.randomization.</span></span><span class="sig-name descname"><span class="pre">EdgeSwitching</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numberOfSwapsPerEdge</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">degreePreservingShufflePreprocessing</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#networkit.randomization.EdgeSwitching" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="base.html#networkit.base.Algorithm" title="networkit.base.Algorithm"><code class="xref py py-class docutils literal notranslate"><span class="pre">Algorithm</span></code></a></p>
<p>The Edge Switching Markov Chain [“The markov chain simulation method for generating connected
power law random graphs”, Mihail and Zegura] perturbs simple directed or undirected graphs
while preserving their degrees. In each step, we select two edges uniformly at random, and
exchange their endpoints. Swaps that introduce multi-edges or self-loops are rejected WITHOUT
replacement – this is necessary to allow uniform sampling [see “Switching edges to randomize
networks: what goes wrong and how to fix it”, Carstens and Horadam]. The number of successful
swaps can be queried using getNumberOfAffectedEdges()/2.</p>
<p>We provide two implementations: EdgeSwitching takes a copy of the input graph and is more
versatile; EdgeSwitchingInPlace works directly on the graph supplied but cannot carry-out
an initial degreePreservingShufflePreprocessing.</p>
<p>In general, simple edge switching does not yield a uniform distribution on simple DIRECTED
graphs because the orientation of directed triangles cannot be changed. Using
DegreePreservingShuffle as a preprocessing step overcomes this limitation. The
preprocessing can also jump-start the perturbation process, yielding to potentially faster
mixing. It is performed by default for owned graphs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> (<em>networkit.Graph</em>) – The graph to be randomized.</p></li>
<li><p><strong>numberOfSwapsPerEdge</strong> (<em>float</em><em>, </em><em>optional</em>) – The average number of swaps to be carried out per edge.
Has to be non-negative. Default: 10.0</p></li>
<li><p><strong>degreePreservingShufflePreprocessing</strong> (<em>bool</em><em>, </em><em>optional</em>) – If true (default), in a preprocessing step jump starts the perturbation process.
For undirected graph, this yields faster mixing; for directed graphs, it is
necessary in order to obtain an unbiased sampling. Default: True</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="networkit.randomization.EdgeSwitching.getGraph">
<span class="sig-name descname"><span class="pre">getGraph</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#networkit.randomization.EdgeSwitching.getGraph" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="networkit.randomization.EdgeSwitching.getNumberOfAffectedEdges">
<span class="sig-name descname"><span class="pre">getNumberOfAffectedEdges</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#networkit.randomization.EdgeSwitching.getNumberOfAffectedEdges" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="networkit.randomization.EdgeSwitching.getNumberOfSwitchesPerEdge">
<span class="sig-name descname"><span class="pre">getNumberOfSwitchesPerEdge</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#networkit.randomization.EdgeSwitching.getNumberOfSwitchesPerEdge" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="networkit.randomization.EdgeSwitching.run">
<span class="sig-name descname"><span class="pre">run</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#networkit.randomization.EdgeSwitching.run" title="Link to this definition">¶</a></dt>
<dd><p>Perform edge switching. May be called multiple times.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="networkit.randomization.EdgeSwitching.setNumberOfSwitchesPerEdge">
<span class="sig-name descname"><span class="pre">setNumberOfSwitchesPerEdge</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">numberOfSwitchesPerEdge</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#networkit.randomization.EdgeSwitching.setNumberOfSwitchesPerEdge" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="networkit.randomization.EdgeSwitchingInPlace">
<span class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></span><span class="sig-prename descclassname"><span class="pre">networkit.randomization.</span></span><span class="sig-name descname"><span class="pre">EdgeSwitchingInPlace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numberOfSwitchesPerEdge</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#networkit.randomization.EdgeSwitchingInPlace" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="base.html#networkit.base.Algorithm" title="networkit.base.Algorithm"><code class="xref py py-class docutils literal notranslate"><span class="pre">Algorithm</span></code></a></p>
<p>The Edge Switching Markov Chain [“The markov chain simulation method for generating connected
power law random graphs”, Mihail and Zegura] perturbs simple directed or undirected graphs
while preserving their degrees. In each step, we select two edges uniformly at random, and
exchange their endpoints. Swaps that introduce multi-edges or self-loops are rejected WITHOUT
replacement – this is necessary to allow uniform sampling [see “Switching edges to randomize
networks: what goes wrong and how to fix it”, Carstens and Horadam]. The number of successful
swaps can be queried using getNumberOfAffectedEdges()/2.</p>
<p>We provide two implementations: EdgeSwitching takes a copy of the input graph and is more
versatile; EdgeSwitchingInPlace works directly on the graph supplied but cannot carry-out
an initial degreePreservingShufflePreprocessing.</p>
<p>In general, simple edge switching does not yield a uniform distribution on simple DIRECTED
graphs because the orientation of directed triangles cannot be changed. Using
DegreePreservingShuffle as a preprocessing step overcomes this limitation. The
preprocessing can also jump-start the perturbation process, yielding to potentially faster
mixing. It is only available for EdgeSwitching.</p>
<p>The implementation keeps a local reference (accessible via getGraph) to prevent premature
garbage collection.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> (<em>networkit.Graph</em>) – The graph to be randomized.</p></li>
<li><p><strong>numberOfSwitchesPerEdge</strong> (<em>int</em><em>, </em><em>optional</em>) – The average number of switches to be carried out per edge.
Has to be non-negative. Default: 10</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="networkit.randomization.EdgeSwitchingInPlace.getGraph">
<span class="sig-name descname"><span class="pre">getGraph</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#networkit.randomization.EdgeSwitchingInPlace.getGraph" title="Link to this definition">¶</a></dt>
<dd><p>Return modified graph.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The graph after applying edge switches.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>networkit.Graph</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="networkit.randomization.EdgeSwitchingInPlace.getNumberOfAffectedEdges">
<span class="sig-name descname"><span class="pre">getNumberOfAffectedEdges</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#networkit.randomization.EdgeSwitchingInPlace.getNumberOfAffectedEdges" title="Link to this definition">¶</a></dt>
<dd><p>Return number of affected edges.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Number of edges affected by edge switches.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="networkit.randomization.EdgeSwitchingInPlace.getNumberOfSwitchesPerEdge">
<span class="sig-name descname"><span class="pre">getNumberOfSwitchesPerEdge</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#networkit.randomization.EdgeSwitchingInPlace.getNumberOfSwitchesPerEdge" title="Link to this definition">¶</a></dt>
<dd><p>Return number of switches per edge.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Number of switches per edges.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>list(int)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="networkit.randomization.EdgeSwitchingInPlace.setNumberOfSwitchesPerEdge">
<span class="sig-name descname"><span class="pre">setNumberOfSwitchesPerEdge</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">numberOfSwitchesPerEdge</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#networkit.randomization.EdgeSwitchingInPlace.setNumberOfSwitchesPerEdge" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="networkit.randomization.GlobalCurveball">
<span class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></span><span class="sig-prename descclassname"><span class="pre">networkit.randomization.</span></span><span class="sig-name descname"><span class="pre">GlobalCurveball</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">number_of_global_rounds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">20</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">allowSelfLoops</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">degreePreservingShufflePreprocessing</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#networkit.randomization.GlobalCurveball" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="base.html#networkit.base.Algorithm" title="networkit.base.Algorithm"><code class="xref py py-class docutils literal notranslate"><span class="pre">Algorithm</span></code></a></p>
<p>Implementation of EM-GCB proposed in “Parallel and I/O-efficient
Randomisation of Massive Networks using Global Curveball Trades”,
Carstens et al., ESA 2018.</p>
<p>The algorithm perturbs an unweighted input graph, by iteratively
randomizing the neighbourhoods of node pairs. For a large number
of global trades this process is shown to produce an uniform sample
from the set of all graphs with the same degree sequence as the input
graph.</p>
<p>If you do not want to explicitly control the trade sequence,
we recommend using GlobalCurveball rather than Curveball since
GlobalCurveball is typically faster and exhibits a smaller memory
footprint.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> (<em>networkit.Graph</em>) – The graph to be randomized. For a given degree sequence, e.g.
generators.HavelHakimi can be used to obtain this graph.</p></li>
<li><p><strong>number_of_global_rounds</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of global rounds to carry out. The runtime scales
asymptotically linearly in this parameter. Default: 20,
which yields good results experimentally (see Paper).</p></li>
<li><p><strong>allowSelfLoops</strong> (<em>bool</em><em>, </em><em>optional</em>) – Has to be False for undirected graphs. For directed graphs
the randomization Markov chain is only irreducible if self loops
are allows. If they are forbidden, the degreePreservingShuffle
preprocessing has to be enabled. Otherwise, not all topologies
can be produced. Default: False</p></li>
<li><p><strong>degreePreservingShufflePreprocessing</strong> (<em>bool</em><em>, </em><em>optional</em>) – Execute the DegreePreservingShuffle algorithm before executing
Global Curveball. It’s more efficient than manually invoking
the algorithm. Default: True</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For directed graphs at least one of allowSelfLoops or
degreePreservingShufflePreprocessing should be set; for more details
refer to “Switching edges to randomize networks: what goes wrong
and how to fix it” by C. J. Carstens K. J. Horadam</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="networkit.randomization.GlobalCurveball.getGraph">
<span class="sig-name descname"><span class="pre">getGraph</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#networkit.randomization.GlobalCurveball.getGraph" title="Link to this definition">¶</a></dt>
<dd><p>Get randomized graph after invocation of run().</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The randomized graph.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>networkit.Graph</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>


    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
        <br/>
        
      
    </p>
    <p style="float:left; max-width: 70%;">
        &copy; Copyright 2018 Humboldt-Universität zu Berlin - Department of Computer Science - Modeling and Analysis of Complex Systems and contributors.<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 9.1.0.<br/>
    </p>
    <span style="padding-left: 10px">
      <a href="https://networkit.github.io/contact.html">Contact, Imprint and Privacy</a>
    </span>
  </div>
</footer>
  </body>
</html>